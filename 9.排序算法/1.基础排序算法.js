//-冒泡排序
/*quote
从第一个元素开始重复比较相邻的两项，若第一项比第二项更大则交换两者位置，反之不动。每一轮操作都会将数组中最大的数放到数组的末尾
*/
//```js
const bubbleSort = (arr) => {
  const len = arr.length;
  // 外层循环用于控制从头到尾的比较+交换到底有多少轮
  for (let i = 0; i < len; i++) {
    // 面向最理想的情况如果数组是有序的
    let flag = false;
    // 内层循环用于完成每一轮遍历过程中的重复比较+交换
    for (let j = 0; j < len - 1 - i; j++) {
      // 若相邻元素前面的数比后面的大
      if (arr[j] > arr[j + 1]) {
        // 交换两者
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
        flag = true;
      }
    }
    if (!flag) return arr;
  }
  // 返回数组
  return arr;
};
//```
/* 
时间复杂度：
最好情况：有序数组 O(n)
平均时间复杂度:O(n^2) 
*/

//-选择排序
/* 
选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。
*/
//```js


//```
